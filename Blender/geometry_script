import bpy, bmesh
from math import pi, cos, sin, tanh

# ------------------ Parametri ------------------
Ri             = 0.25
b0             = 0.05
Ro             = Ri + b0
H              = 0.20
nZ             = 20           # numero di layer in Z

# >>> NUOVO: definizione angolare in gradi <<<
alpha_deg      = 2.8125       # piccolo angolo del singolo settore (esempio)
theta_geo_deg  = alpha_deg    # estensione geometrica totale (alpha_deg <= theta_geo_deg <= 360)

nRInner        = 5            # anelli tra core e Ri
nRAnn          = 2*nRInner    # anelli tra Ri e Ro
n_Cushion_inlet = 1           # 0 <= n_Cushion_inlet < nRInner
coreFrac       = 1e-2         # piccolo raggio core per O-grid quad-only

# >>> NUOVO: controlli infittimento <<<
# kZ        : infittimento in Z verso z=0 (0=uniforme, >0 più fitto in basso)
# kR_cush   : infittimento radiale nel cushion verso Ri
# kR_ann    : infittimento radiale nell'annulus verso Ri
kZ            = 2.0
kR_cush       = 2.0
kR_ann        = 2.0

name_all = "hoover_domain"

# ------------------ Material slots (ordine fisso) ------------------
# Slot 0 *deve* essere interno, così qualunque faccia non marcata NON finisce in una patch di bordo.
MAT_ORDER = [
    "_internal",       # 0 - interno / non-boundary
    "inlet_cushion",   # 1 - top cap r <= soglia cushion inlet
    "inlet_annulus",   # 2 - top cap annulus
    "cushionTopWall",  # 3 - porzione top cushion trasformata in wall
    "bottomWall",      # 4 - base
    "outerWall",       # 5 - cilindro esterno
    "innerAxis",       # 6 - cilindro interno
    "wedgeLow",        # 7 - piano azimutale a theta_min (solo wedge)
    "wedgeHigh",       # 8 - piano azimutale a theta_max (solo wedge)
]
MAT_IDX = {n:i for i,n in enumerate(MAT_ORDER)}

# ------------------ Utilità ------------------
def safe_remove(obj):
    if obj and obj.name in bpy.data.objects:
        me = obj.data
        bpy.data.objects.remove(obj, do_unlink=True)
        if me and me.users == 0:
            bpy.data.meshes.remove(me, do_unlink=True)

def remove_if_exists(name):
    safe_remove(bpy.data.objects.get(name))

# >>> NUOVO: funzione di clustering [0..1] -> [0..1]
def cluster01(n, k, toward=1):
    """
    Restituisce n+1 posizioni in [0,1] con infittimento controllato da k>=0.
    toward=1  -> infittisce verso 1 (estremo alto)
    toward=0  -> infittisce verso 0 (estremo basso)
    k=0       -> distribuzione lineare uniforme
    Mappa: f(s) = tanh(k*s)/tanh(k) (o simmetrica) per s in [0,1]
    """
    if n <= 0:
        return [0.0]
    if k <= 0.0:
        return [i/n for i in range(n+1)]
    out = []
    for i in range(n+1):
        s = i / n
        if toward == 1:
            val = tanh(k * s) / tanh(k)
        else:
            # cluster verso 0 ⇒ mappa simmetrica
            val = 1.0 - tanh(k * (1.0 - s)) / tanh(k)
        out.append(val)
    return out

bpy.context.scene.unit_settings.system = 'METRIC'
bpy.context.scene.unit_settings.scale_length = 1.0

remove_if_exists(name_all)

# Layer in Z
nLayers = max(1, int(nZ))
dz      = H / nLayers  # solo per stampa

# >>> NUOVO: livelli Z non uniformi (cluster verso z=0)
_z01 = cluster01(nLayers, kZ, toward=0)  # toward=0 -> più denso vicino a z=0
z_levels = [H * t for t in _z01]         # lunghezza nLayers+1; z_levels[0]=0, z_levels[-1]=H

# ------------------ Helper theta (NUOVO in gradi) ------------------
def theta_config_from_degs(alpha_deg, theta_geo_deg):
    """
    Restituisce:
      - nVertsPerRing (punti per anello),
      - wrap (bool: True se 360° pieni),
      - theta_span (radians), ampiezza effettiva totale,
      - a0 (radians), angolo iniziale (centrato intorno a 0)
      - nSectors (numero di settori; 1 => semplice wedge)
    Regole:
      - nSectors = round(theta_geo_deg / alpha_deg), minimo 1
      - eff_span = min(360, nSectors * alpha_deg)
      - wrap = True se eff_span == 360
      - Un settore ha 1 cella in theta. Se wrap:
          nVerts = nSectors   (ciclo chiuso)
        else:
          nVerts = nSectors+1 (aperto, con due bordi wedge)
      - Viene centrato in [-eff_span/2, +eff_span/2] rispetto a 0°
    """
    assert alpha_deg > 0.0, "alpha_deg dev'essere > 0"
    theta_geo_deg = max(alpha_deg, min(360.0, float(theta_geo_deg)))
    nSectors = max(1, int(round(theta_geo_deg / alpha_deg)))
    eff_span_deg = min(360.0, nSectors * alpha_deg)

    wrap = abs(eff_span_deg - 360.0) < 1e-9
    if wrap:
        nVerts = nSectors
        a0_deg = -180.0     # arbitrario: centrato su 0, ma fa il giro completo
    else:
        nVerts = nSectors + 1
        a0_deg = -0.5 * eff_span_deg

    theta_span = eff_span_deg * pi/180.0
    a0 = a0_deg * pi/180.0
    return nVerts, wrap, theta_span, a0, nSectors, eff_span_deg

# ------------------ Primitive ------------------
def ring_partial(bm, r, z, nVerts, wrap, theta_span, a0=0.0):
    """
    Crea un anello parziale:
      - se wrap=True: nVerts punti equispaziati su 360° (theta_span=2*pi), inizia da a0
      - se wrap=False: nVerts punti da a0 a a0+theta_span, inclusi i due estremi
    """
    verts = []
    if wrap:
        for k in range(nVerts):
            a = a0 + 2*pi * k / nVerts
            verts.append(bm.verts.new((r*cos(a), r*sin(a), z)))
    else:
        for k in range(nVerts):
            a = a0 + theta_span * k / (nVerts - 1)
            verts.append(bm.verts.new((r*cos(a), r*sin(a), z)))
    return verts

def quad_strip_mat(bm, ring_in, ring_out, wrap, mat_index=None):
    """
    Crea quad tra due anelli.
    Se mat_index è None, assegna esplicitamente _internal per evitare materiale 0 sbagliato.
    """
    if mat_index is None:
        mat_index = MAT_IDX["_internal"]
    n = len(ring_in)
    if wrap:
        for k in range(n):
            f = bm.faces.new((ring_in[k], ring_in[(k+1)%n], ring_out[(k+1)%n], ring_out[k]))
            f.material_index = mat_index
    else:
        for k in range(n-1):
            f = bm.faces.new((ring_in[k], ring_in[k+1], ring_out[k+1], ring_out[k]))
            f.material_index = mat_index

def cap_between_rings_with_mat(bm, rings, wrap, mat_idx_per_i):
    for i in range(len(rings)-1):
        quad_strip_mat(bm, rings[i], rings[i+1], wrap, mat_idx_per_i[i])

def add_radial_vertical_faces(bm, prev_rings, curr_rings, wrap):
    """
    Pareti radiali verticali tra layer (piani θ = costante).
    In wedge multi-settore: k=0 -> wedgeLow, k=nVerts-1 -> wedgeHigh. Altre radiali -> _internal.
    In full 360 wrap: tutte -> _internal.
    """
    n = len(prev_rings[0])
    for i in range(len(prev_rings) - 1):
        A0, B0 = prev_rings[i],   prev_rings[i+1]
        A1, B1 = curr_rings[i],   curr_rings[i+1]
        for k in range(n):
            f = bm.faces.new((A0[k], A1[k], B1[k], B0[k]))
            if not wrap:
                if k == 0:
                    f.material_index = MAT_IDX["wedgeLow"]
                elif k == n-1:
                    f.material_index = MAT_IDX["wedgeHigh"]
                else:
                    f.material_index = MAT_IDX["_internal"]
            else:
                f.material_index = MAT_IDX["_internal"]

# ------------------ COSTRUTTORE UNICO + TAG MATERIALI ------------------
def make_domain_unico_with_materials(name, Ri, Ro, H, nLayers,
                                     alpha_deg, theta_geo_deg,
                                     nRInner, nRAnn, n_Cushion_inlet, coreFrac,
                                     # >>> NUOVO: passaggio parametri clustering <<<
                                     kZ, kR_cush, kR_ann):
    assert 0 <= n_Cushion_inlet < nRInner, "n_Cushion_inlet deve essere in [0, nRInner-1]"

    nVertsTheta, wrap, theta_span, a0, nSectors, eff_span_deg = theta_config_from_degs(alpha_deg, theta_geo_deg)

    bm = bmesh.new()

    # radii: core -> Ri (cushion), poi Ri -> Ro (annulus)
    rCore = max(1e-9, coreFrac*Ri)

    # >>> NUOVO: liste r con infittimento vicino a Ri <<<
    # cushion: cluster verso 1 (Ri)
    _rc = cluster01(nRInner, kR_cush, toward=1)            # [0..1]
    radii_cush = [rCore + (Ri - rCore) * t for t in _rc]   # include Ri (ultimo)

    # annulus: cluster verso 0 (Ri)
    _ra = cluster01(nRAnn, kR_ann, toward=0)               # [0..1], 0=Ri
    radii_ann  = [Ri + (Ro - Ri) * t for t in _ra][1:]     # salta Ri (t=0)

    radii_full = radii_cush + radii_ann

    # strip con base a Ri (tra i e i+1) -> indice separazione cushion/annulus
    i_Ri = len(radii_cush) - 1  # = nRInner

    # --- base (z=0): tutto bottomWall ---
    z0 = 0.0
    base_rings = [ring_partial(bm, r, z0, nVertsTheta, wrap, theta_span, a0) for r in radii_full]
    mat_bottom_per_i = [MAT_IDX["bottomWall"]] * (len(base_rings)-1)
    cap_between_rings_with_mat(bm, base_rings, wrap, mat_bottom_per_i)

    # --- estrusione in Z: pareti cilindriche + radiali ---
    prev_rings = base_rings

    # >>> NUOVO: uso livelli Z non uniformi
    for L in range(1, nLayers+1):
        z = z_levels[L]
        curr_rings = []
        for prev in prev_rings:
            curr_rings.append([bm.verts.new((v.co.x, v.co.y, z)) for v in prev])

        # cilindriche: marchiamo SOLO inner/outer; le altre -> _internal
        for j, (prev, curr) in enumerate(zip(prev_rings, curr_rings)):
            if j == 0:
                quad_strip_mat(bm, prev, curr, wrap, MAT_IDX["innerAxis"])
            elif j == len(prev_rings)-1:
                quad_strip_mat(bm, prev, curr, wrap, MAT_IDX["outerWall"])
            else:
                quad_strip_mat(bm, prev, curr, wrap, MAT_IDX["_internal"])

        # radiali verticali (wedge ai bordi estremi; interni -> _internal)
        add_radial_vertical_faces(bm, prev_rings, curr_rings, wrap)

        prev_rings = curr_rings

    # --- top cap (z=H): split in tre zone ---
    # i in [0 .. nRInner-1]  --> cushion (diviso in inlet vs wall)
    # i in [nRInner .. end]  --> annulus inlet
    mat_top_per_i = []
    last_strip_index = len(prev_rings) - 2
    for i in range(last_strip_index + 1):
        if i < i_Ri:
            # top cushion
            if i < n_Cushion_inlet:
                mat_top_per_i.append(MAT_IDX["inlet_cushion"])   # ingresso cushion (normale z)
            else:
                mat_top_per_i.append(MAT_IDX["cushionTopWall"])  # tappo cushion (normale z)
        else:
            mat_top_per_i.append(MAT_IDX["inlet_annulus"])       # ingresso annulus (normale z)

    cap_between_rings_with_mat(bm, prev_rings, wrap, mat_top_per_i)

    # --- crea mesh/oggetto ---
    me = bpy.data.meshes.new(name)
    bm.to_mesh(me)
    bm.free()
    obj = bpy.data.objects.new(name, me)

    for mat_name in MAT_ORDER:
        mat = bpy.data.materials.get(mat_name) or bpy.data.materials.new(mat_name)
        obj.data.materials.append(mat)

    bpy.context.collection.objects.link(obj)
    return obj, nVertsTheta, wrap, theta_span, a0, nSectors, eff_span_deg

# ------------------ CREA OGGETTO ------------------
obj, nVertsTheta, wrap, theta_span, a0, nSectors, eff_span_deg = make_domain_unico_with_materials(
    name_all, Ri, Ro, H, nLayers,
    alpha_deg, theta_geo_deg,
    nRInner, nRAnn, n_Cushion_inlet, coreFrac,
    # >>> NUOVO: passi i tre parametri di infittimento <<<
    kZ, kR_cush, kR_ann
)

print(f"OK: '{name_all}' — H={H}, nZ={nLayers}, dz_media={H/nLayers:.6f}")
print(f"alpha = {alpha_deg:.6f} deg | theta_geo = {theta_geo_deg:.6f} deg")
print(f"eff_span = {eff_span_deg:.6f} deg | nSectors = {nSectors} | mode = {'full-360 wrap' if wrap else 'wedge'}")
print(f"theta: verts/anello = {nVertsTheta}, a0 = {a0*180/pi:.6f} deg, span = {theta_span*180/pi:.6f} deg")
print("Material slots:", MAT_ORDER)
print("Tip: Edit Mode → Select by Material → crea/Assign le patch SwiftBlock. "
      "NON creare patch per '_internal'.")
print(f"[INFO] Clustering: kZ={kZ} (verso z=0), kR_cush={kR_cush} (verso Ri nel cushion), kR_ann={kR_ann} (verso Ri nell'annulus)")
